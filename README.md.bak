# lfn

Array transformations
-----------------------------
* shuffle( array, ?random ) -> array
```
fn.shuffle{1,2,3,4}
```

* sort( array, ?lt ) -> array
```
fn.sort{1,3,-1,4,5} -- {-1,1,3,4,5}
fn.sort({{1,'red'},{-1,'black'},{2,'green'}}, fn.lambda'x[1]<y[1]') -- {{-1,'black'},{1,'red'},{2,'green'}}
```

* reverse( array ) -> array
```
fn.reverse{1,2,3} -- {3,2,1}
```

* concat( array, ?delimiter ) -> table.concat( array, delimiter )

Stream iterators
----------------
* range( from, ?to, ?step ) -> iterator returning values in range
* iter( array ) -> iterator returning value
* ipairs( array ) -> iterator returning pair index, value
* riter( arary ) -> reverse iterartor returning value
* ripairs( array ) -> reverse iterator returning pair index value
* pairs( table ) -> iterator returning pair key, value
* keys( table ) -> iterator returning key
* values( table ) -> iterator returning value

Stream transfomations
---------------------

* map( iterator, f ) -> f( iterator())
* filter( iterator, p ) -> returns iterator() if p( iterator()) holds
* unique( iterator ) -> returns iterator() if first value is unique in current stream
* slice( iterator, from, ?to, ?step ) -> returns iterator() if first value > from and < to
* insert( iterator, ?index or iterator2, iterator2 ) -> returns iterator() if first value
* swap( iterator ) -> returns iterator() results swapped
* update( iterator, table ) -> returns iterator() or table[iterator()] if table has key

Stream folds
------------
* toarray( iterator ) -> make array from first values
* totable( iterator ) -> make table from first and second values
* toset( iterator ) -> make table with keys from first values and true as values
* reduce( iterator, f, acc ) -> calls f( acc, ... ) -> newacc for each value and returns resulting acc
```
fn.enumerate{1,2,3,4,5}:filter( fn.lambda'x>2' ):reduce( fn.op'-', 0 )
```
* sum( iterator, ?acc) -> returns sum of values
* all( iterator, p ) -> returns true if p holds for all elements
* any( iterator, p ) -> returns true if p holds for any one of elements
* count( iterator, ?p ) -> return count of items for which p holds( if not specified then just counts all items)
* each( iterator, f ) -> calls f( iterator()) and returns nothing

Additional functions
--------------------
* indexof( array, value, ?lt ) -> returns index of value; if lt specified then uses binary search ( array must be sorted )
* equal( any, any ) -> make deep comparsion of tables( for other values uses == ), note that it
doesnt work for tables with table keys (equal( {[{1}] = 2} , {[{1}] = 2} ) == false )
* lambda( string ) -> returns lambda one-liner from string, which has 6 variables: x, y, z, u, v, w
* op( string ) -> predefined operators 
	+,-,*,/,//,^,%,neg(unary minus)
	==,~=,<,>,<=,>=,
	--,++
	#, .. 
	and,or,not
	nil?, boolean?, number?, integer?, function?, userdata?, thread?, string?, table?
	equal? zero? positive? negative? even? odd?

Special values
--------------
* wild -> wild symbol for equal function
* rest -> rest for equal function
